---
title: "How Good Are Confidence Intervals?"
subtitle: "Determining Default CI Width Selection From Simulations"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
editor_options:
  chunk_output_type: console
---
```{r setup, message=FALSE, warning=FALSE, include=FALSE}
require(tidyverse)
require(tidymodels)
require(nationalparkcolors)
require(RColorBrewer)
require(GenomicRanges)
```

Analysis date: `r format(Sys.time(), '%B %d, %Y')`

```{r message=FALSE, warning=FALSE, include=FALSE}
setwd("~/Documents/projects/NemaScan_Performance/")
load(file = "data/NemaScan_Performance.CeNDR2020_PowerPrecision_GAMMA.20200909.RData")
dat <- simuation.metrics.df %>%
  tidyr::separate(col = sim,
                  into = c("nQTL","Rep","h2","MAF","effect_range","strain_set"), 
                  sep = "_", remove = F) %>%
  tidyr::separate(col = QTL,
                  into = c("CHROM","POS"), 
                  sep = ":", remove = F) %>%
  dplyr::mutate(h2 = as.factor(h2),
                POS = as.numeric(POS))
```

## Simulation Parameters

NemaScan simulation performance was assessed with the following experimental parameters:

* ###### Number of Simulated QTL: ```r levels(as.factor(dat$nQTL))```
* ###### Sample Population(s): ```r levels(as.factor(dat$strain_set))```
* ###### Heritability(ies): ```r levels(as.factor(dat$h2))```
* ###### MAF(s): ```r levels(as.factor(dat$MAF))```
* ###### Number of Replicates per Regime: ```r max(as.numeric(dat$Rep))```
* ###### QTL Effect Range: ```r levels(as.factor(dat$effect_range))```

## Simulated QTL Locations
```{r simulated QTL locations, echo=FALSE}
dat %>%
  dplyr::filter(Simulated == TRUE) %>%
  dplyr::filter(!is.na(CHROM)) %>%
  ggplot(mapping = aes(x = POS/1000000, y = Effect)) + 
  theme_bw() + 
  geom_point() + 
  facet_grid(.~CHROM, drop = TRUE) + 
  labs(x = "Genomic position (Mb)",
       y = "Causal QTL Effect",
       title = "Where were QTL Simulated?")

dat %>%
  dplyr::filter(Simulated == TRUE) %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  dplyr::filter(!is.na(CHROM)) %>%
  ggplot(mapping = aes(x = Frequency, fill = Simulated)) +
  theme_minimal() + 
  geom_density() + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[1]) + 
  theme(legend.position = "none") + 
  xlim(c(0.05,0.5)) + 
  labs(x = "Minor Allele Frequency",
       y = "Frequency of Simulated QTL (Smoothed Density)")
```

```{r power precision resolution, echo=FALSE}
power <- dat %>%
  dplyr::group_by(h2, algorithm) %>%
  yardstick::sens(truth = Simulated, estimate = Detected) %>%
  dplyr::mutate(.metric = "Power")

precision <- dat %>%
  dplyr::group_by(h2, algorithm) %>%
  yardstick::precision(truth = Simulated, estimate = Detected) %>%
  dplyr::mutate(.metric = "Precision")

resolution <- dat %>%
  dplyr::filter(Detected == TRUE) %>%
  dplyr::filter(!is.na(var.exp)) %>%
  dplyr::select(CHROM, POS, Simulated, Frequency, interval_size, algorithm, h2, var.exp) %>%
  dplyr::group_by(h2, algorithm) %>%
  dplyr::summarise(mean(interval_size), median(interval_size), sd(interval_size), 
                   mean(var.exp), median(var.exp), sd(var.exp))

summarized <- power %>%
  dplyr::full_join(., precision) %>%
  tidyr::pivot_wider(names_from = .metric, values_from = .estimate) %>%
  dplyr::left_join(.,resolution) %>%
  dplyr::mutate(mean.interval.Mb = `mean(interval_size)`/1000000,
                median.interval.Mb = `median(interval_size)`/1000000,
                sd.interval.Mb = `sd(interval_size)`/1000000, 
                mean.PVE = `mean(var.exp)`*100,
                median.PVE = `median(var.exp)`*100,
                sd.PVE = `sd(var.exp)`*100, 
                .keep = "unused")
```

## False-Positive Metrics
```{r closest FP calculation, echo=FALSE, message=FALSE, warning=FALSE}
reps <- dat %>%
  dplyr::group_by(h2, Rep, algorithm) %>%
  tidyr::nest()

# data = reps$data[[214]]
# rep = reps$Rep[[214]]
# h2 = reps$h2[[214]]
# algorithm = reps$algorithm[[214]]

closest.FP.calc <- function(data, rep, h2, algorithm){
# ALL REPS SEPARATED:
  chrom.split <- data %>%
    dplyr::group_by(CHROM) %>%
    tidyr::nest()
# CHROMOSOME LOOP START
  closest.FP <- list()
  for(i in 1:length(chrom.split$data)){
  rep.CHROM <- chrom.split$data[[i]]
# SEARCH FOR CLOSEST SIMULATED QTL
# CALCULATE ABS(DISTANCE) FROM IT
  if(TRUE %in% rep.CHROM$Simulated){
    n.true.qtl <- length(rep.CHROM$Simulated[which(rep.CHROM$Simulated == TRUE)])
    # more than 1 simulated QTL on the chromosome
    if(n.true.qtl > 1){
      simulated.QTL.POS <- rep.CHROM %>%
      dplyr::filter(Simulated == TRUE) %>%
      dplyr::select(POS) %>%
      as.list()
    
      dist.from.QTL <- list()
      for(j in 1:nrow(rep.CHROM)){
        QTL.dists <- list()
        for(k in 1:length(simulated.QTL.POS[[1]])){
        QTL.dists[[k]] <- rep.CHROM[j,]$POS - simulated.QTL.POS[[1]][k]
      }
      dist.from.QTL[[j]] <- min(abs(unlist(QTL.dists)))
    }
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = unlist(dist.from.QTL))%>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])
    
  } else {
    # only 1 simulated QTL on the chromosome
    simulated.QTL.POS  <- rep.CHROM %>%
      dplyr::filter(Simulated == TRUE) %>% 
      dplyr::select(POS) %>%
      as.numeric()
    
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = abs(as.numeric(rep.CHROM$POS) - simulated.QTL.POS)) %>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])
  }
} else {
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = "Extra-Chromosomal False-Positive")%>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])}
  }
  do.call(rbind, closest.FP) %>%
    as.data.frame() %>%
    dplyr::mutate(Rep = rep, 
                  h2 = h2,
                  algorithm = algorithm)
}
closest.FP.nested <- purrr::pmap(.l = list(reps$data,
                                      reps$Rep,
                                      reps$h2,
                                      reps$algorithm), 
                                 .f = closest.FP.calc)
closest.FP.df <- do.call(rbind, closest.FP.nested)

closest.FP.table <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::group_by(h2, algorithm) %>%
  dplyr::summarise(mean(as.numeric(dist.from.QTL))) %>%
  tidyr::pivot_wider(names_from = h2, values_from = `mean(as.numeric(dist.from.QTL))`)

closest.ExtraCHROM.FP.table <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive") %>%
  dplyr::group_by(h2, algorithm) %>%
  dplyr::summarise(n()) %>%
  tidyr::pivot_wider(names_from = h2, values_from = `n()`)

print(knitr::kable(closest.FP.table, 
                   format = "pandoc",
                   caption = "Average Distance Between False-Positives and the Nearest Simulated QTL",
                   digits = 3))

print(knitr::kable(closest.ExtraCHROM.FP.table, 
                   format = "pandoc",
                   caption = "Number of Extra-Chromosomal False-Positives",
                   digits = 3))

```

## QTL Resolution Analysis 
```{r interval width plots, echo=FALSE}
summarized %>%
  dplyr::mutate(h2 = as.numeric(levels(h2))[h2]) %>%
  ggplot(., mapping = aes(x = h2, y = mean.interval.Mb, colour = algorithm)) +
  theme_minimal() +
  geom_pointrange(aes(ymin = mean.interval.Mb-sd.interval.Mb,
                      ymax = mean.interval.Mb+sd.interval.Mb), alpha = 0.7) +
  scale_colour_manual(values = nationalparkcolors::park_palettes$Hawaii[c(5,1,2)], name = "Mapping Algorithm") + 
  labs(title = "QTL Resolution v. Heritability",
       x = expression(italic(h^2)),
       y = "Mean QTL Interval Width (Mb)")
```

## Intra-Chromosomal False-Positives
```{r IntraChromosomal FPs, echo=FALSE, fig.height=5.5, fig.width=8, message=FALSE, warning=FALSE, paged.print=TRUE}
closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::filter(as.numeric(dist.from.QTL) > 0) %>%
  dplyr::arrange(h2) %>%
  ggplot(., mapping = aes(x = as.numeric(dist.from.QTL)/1000000, stat(count), fill = h2)) + 
  theme_minimal() + 
  geom_density( position = "stack") + 
  facet_grid(algorithm~.) + 
  scale_fill_brewer(palette = "Greens", name = "Trait Heritability") + 
  theme(legend.position = "top") + 
  labs(x = "False-Positive Distance from Nearest Simulated QTL (Mb)",
       y = "Frequency")

closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::filter(as.numeric(dist.from.QTL) > 0) %>%
  dplyr::arrange(h2) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = h2)) +
  theme_minimal() +
  geom_point(alpha = 0.4, shape = 21) +
  facet_grid(.~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_brewer(palette = "Greens", name = "Trait Heritability") +
  theme(legend.position = "top") + 
  ggtitle("Intra-Chromosomal False-Positives")

closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::filter(as.numeric(dist.from.QTL) > 0) %>%
  dplyr::arrange(h2) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = algorithm)) +
  theme_minimal() +
  geom_point(alpha = 0.4, shape = 21) +
  facet_grid(.~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Hawaii[c(5,1,2)], name = "Mapping Algorithm") + 
  theme(legend.position = "top") + 
  ggtitle("Intra-Chromosomal False-Positives")

for.binning <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::filter(as.numeric(dist.from.QTL) > 0) %>%
  dplyr::group_by(CHROM, algorithm) %>%
  tidyr::nest()
fp.bins <- function(data, chrom, algo){
  data %>%
  dplyr::mutate(pos.bin = cut(as.numeric(peakPOS), 10000)) %>%
  dplyr::group_by(pos.bin) %>%
  dplyr::summarise(mean(log10p), median(POS), n()) %>%
  dplyr::mutate(CHROM = chrom,
                algorithm = algo)
}
fp.bins.list <- purrr::pmap(.l = list(for.binning$data, 
                                    for.binning$CHROM,
                                    for.binning$algorithm), .f = fp.bins)
fp.bins.df <- do.call(rbind, fp.bins.list) %>%
  dplyr::mutate(`mean(log10p)` = dplyr::if_else(`mean(log10p)` == "Inf", 
                                                true = 0, 
                                                false = `mean(log10p)`),
                top.end = `n()` > quantile(`n()`, seq(0,1, by = 0.05))[20])
ggplot(fp.bins.df, mapping = aes(x = `median(POS)`/1000000, y = `n()`, fill = top.end)) +
  theme_minimal() +
  geom_point(shape = 21) +
  facet_grid(algorithm~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = "Number of False-Positives per Bin") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Yellowstone[c(3,6)], name = "Top 5%") + 
  theme(legend.position = "top") + 
  ggtitle("Intra-Chromosomal False-Positives")
```

## Extra-Chromosomal False-Positives
```{r ExtraChromosomal FPs, echo=FALSE, fig.height=5.5, fig.width=8, message=FALSE, warning=FALSE, paged.print=TRUE}
closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive") %>%
  dplyr::arrange(h2) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = h2)) +
  theme_minimal() +
  geom_point(alpha = 0.4, shape = 21) +
  facet_grid(.~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_brewer(palette = "Greens", name = "Trait Heritability") +
  theme(legend.position = "top") + 
  ggtitle("Extra-Chromosomal False-Positives")

closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive") %>%
  dplyr::arrange(algorithm) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = algorithm)) +
  theme_minimal() +
  geom_point(alpha = 0.5, shape = 21) +
  facet_grid(.~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Hawaii[c(5,1,2)], name = "Mapping Algorithm") + 
  theme(legend.position = "top") + 
  ggtitle("Extra-Chromosomal False-Positives")

for.binning <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive") %>%
  dplyr::group_by(CHROM, algorithm) %>%
  tidyr::nest()
fp.bins <- function(data, chrom, algo){
  data %>%
  dplyr::mutate(pos.bin = cut(as.numeric(peakPOS), 10000)) %>%
  dplyr::group_by(pos.bin) %>%
  dplyr::summarise(mean(log10p), median(POS), n()) %>%
  dplyr::mutate(CHROM = chrom,
                algorithm = algo)
}
fp.bins.list <- purrr::pmap(.l = list(for.binning$data, 
                                    for.binning$CHROM,
                                    for.binning$algorithm), .f = fp.bins)
fp.bins.df <- do.call(rbind, fp.bins.list) %>%
  dplyr::mutate(`mean(log10p)` = dplyr::if_else(`mean(log10p)` == "Inf", 
                                                true = 0, 
                                                false = `mean(log10p)`),
                top.end = `n()` > quantile(`n()`, seq(0,1, by = 0.05))[20])

ggplot(fp.bins.df, mapping = aes(x = `median(POS)`/1000000, y = `n()`, fill = top.end)) +
  theme_minimal() +
  geom_point(shape = 21) +
  facet_grid(algorithm~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = "Number of False-Positives per Bin") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[c(1,4)], name = "Top 5%") + 
  theme(legend.position = "top") + 
  ggtitle("Extra-Chromosomal False-Positives")
```

## False-Positives and Divergent Regions
```{r divergent region assessment, include=FALSE}
common.divergent.regions <- data.table::fread("data/Common_divergent_regions_clustered.tsv") %>%
  dplyr::mutate(chr = as.factor(chr))
levels(common.divergent.regions$chr) <- c("1","2","3","4","5","6")
div.regions.gr <- GenomicRanges::GRanges(seqnames = common.divergent.regions$chr, 
                                         ranges = IRanges(start = common.divergent.regions$start, 
                                                          end = common.divergent.regions$stop))
# Simulated QTL
simulated <- dat %>%
  dplyr::filter(Simulated == TRUE)
simulated.gr <- GenomicRanges::GRanges(seqnames = simulated$CHROM, 
                                            ranges = IRanges(start = simulated$POS, 
                                                             end = simulated$POS),
                                            QTL = simulated$QTL)
divergent.simulated <- IRanges::findOverlapPairs(simulated.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL,first.X.seqnames, first.X.start, 
                second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","POS","div.start","div.end"))
```

### Simulated QTL Locations and Divergence
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Causal QTL v. Divergence
simulated %>%
  dplyr::mutate(divergent = ifelse(test = QTL %in% divergent.simulated$QTL, 
                                   yes = "Divergent", 
                                   no = "Non-Divergent"),
                detected = ifelse(test = Detected == TRUE, 
                                  yes = "Detected",
                                  no = "Not Detected")) %>%
  dplyr::filter(!duplicated(paste(QTL))) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = Effect, fill = divergent)) +
  theme_bw() +
  geom_point(alpha = 0.8, shape = 21) +
  facet_grid( algorithm ~ CHROM) +
  labs(x = "Genomic position (Mb)",
       y = "Causal QTL Effect") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergent Region?") + 
  theme(legend.position = "top") + 
  ggtitle("Are Simulated QTL in Divergent Regions?")

simulated.QTL.by.divergence <- simulated %>%
  dplyr::mutate(divergent = ifelse(test = QTL %in% divergent.simulated$QTL, 
                                   yes = "Divergent", 
                                   no = "Non-Divergent"),
                detected = ifelse(test = Detected == TRUE, 
                                  yes = "Detected",
                                  no = "Not Detected")) %>%
  dplyr::filter(!duplicated(paste(QTL))) %>%
  dplyr::group_by(divergent, detected) %>%
  dplyr::summarise(n()) %>%
  tidyr::pivot_wider(values_from = `n()`, names_from = divergent) %>%
  as.data.frame()

rownames(simulated.QTL.by.divergence) <- simulated.QTL.by.divergence$detected
simulated.QTL.by.divergence.xsq <- simulated.QTL.by.divergence %>%
  dplyr::select(-detected)
print("Are Divergent Regions Disproportionately Represented in Simulated QTL?")
simulated.QTL.by.divergence.xsq
chisq.test(x = simulated.QTL.by.divergence.xsq,simulate.p.value = T)
```

### Statistical Testing - Minor Allele Frequencies
To facilitate initial analyses, differences among groups were calculated using Two-Way ANOVA. 
```{r echo=FALSE, message=FALSE, warning=FALSE}
test <- simulated %>%
  dplyr::mutate(divergent = ifelse(test = QTL %in% divergent.simulated$QTL, 
                                   yes = "Divergent", 
                                   no = "Non-Divergent"),
                detected = ifelse(test = Detected == TRUE, 
                                  yes = "Detected",
                                  no = "Not Detected"))

# Stats
test %>%
  group_by(detected, divergent, algorithm) %>%
  dplyr::summarise(mean(Frequency)) %>%
  tidyr::pivot_wider(values_from = `mean(Frequency)`, names_from = c(detected, divergent))
```

#### EMMAx
```{r}
print("Two-Way ANOVA:EMMAx")
freq.aov <- test %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  aov(., formula = Frequency ~ detected * divergent)
summary(freq.aov)
TukeyHSD(freq.aov)
```

#### LMM-EXACT
```{r}
print("Two-Way ANOVA:LMM-EXACT")
freq.aov <- test %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  aov(., formula = Frequency ~ detected * divergent)
summary(freq.aov)
TukeyHSD(freq.aov)
```

#### LMM-EXACT with Inbred Kinship Matrix
```{r}
print("Two-Way ANOVA:LMM-EXACT-INBRED")
freq.aov <- test %>%
  dplyr::filter(algorithm == "LMM-EXACT-INBRED") %>%
  aov(., formula = Frequency ~ detected * divergent)
summary(freq.aov)
TukeyHSD(freq.aov)
```

#### Comparison Plots
```{r echo=FALSE}
test %>%
  dplyr::filter(!duplicated(paste(QTL,algorithm))) %>%
  ggplot(., mapping = aes(x = detected, y = Frequency, fill = divergent)) +
  theme_minimal() +
  facet_grid(algorithm ~ .) +
  geom_violin(alpha = 0.8, draw_quantiles = seq(0,1,0.25)) + 
  labs(x = "Genome-Wide Association Status",
       y = "Minor Allele Frequency") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergent Region?") + 
  theme(legend.position = "top") + 
  ggtitle("How Frequent Are Divergent QTL?")

```

### Statistical Testing - QTL Effects
Since these are known to be Gamma distributed, differences among groups were calculated using Kruskal-Wallis Rank Sum Tests, with conditioning on mapping algorithms and 1) divergence classification or 2) detection in the pipeline.

#### EMMAx
```{r echo=FALSE}
# Effects
print("EMMAx KRUSKALL WALLIS")
print("Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Divergent") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are divergent QTL MAFs different between detected and undetected QTLs?
print("Non-Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Non-Divergent") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are non-divergent QTL MAFs different between detected and undetected QTLs?
print("Undetected QTLs Only")
test %>%
  dplyr::filter(detected == "Not Detected") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are undetected QTL MAFs different between divergent and non-divergent regions?
print("Detected QTLs Only")
test %>%
  dplyr::filter(detected == "Detected") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are detected QTL MAFs different between divergent and non-divergent regions?
```

#### LMM-EXACT
```{r echo=FALSE}
print("LMM-EXACT KRUSKALL WALLIS")
print("Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Divergent") %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are divergent QTL MAFs different between detected and undetected QTLs?
print("Non-Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Non-Divergent") %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are non-divergent QTL MAFs different between detected and undetected QTLs?
print("Undetected QTLs Only")
test %>%
  dplyr::filter(detected == "Not Detected") %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are undetected QTL MAFs different between divergent and non-divergent regions?
print("Detected QTLs Only")
test %>%
  dplyr::filter(detected == "Detected") %>%
  dplyr::filter(algorithm == "LMM-EXACT") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are detected QTL MAFs different between divergent and non-divergent regions?
```

#### LMM-EXACT with Inbred Kinship Matrix
```{r echo=FALSE}
print("LMM-EXACT-INBRED KRUSKALL WALLIS")
print("Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Divergent") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are divergent QTL MAFs different between detected and undetected QTLs?
print("Non-Divergent QTLs Only")
test %>%
  dplyr::filter(divergent == "Non-Divergent") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ detected, data = .) # Are non-divergent QTL MAFs different between detected and undetected QTLs?
print("Undetected QTLs Only")
test %>%
  dplyr::filter(detected == "Not Detected") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are undetected QTL MAFs different between divergent and non-divergent regions?
print("Detected QTLs Only")
test %>%
  dplyr::filter(detected == "Detected") %>%
  dplyr::filter(algorithm == "EMMAx") %>%
  kruskal.test(Frequency ~ divergent, data = .) # Are detected QTL MAFs different between divergent and non-divergent regions?
```

#### Comparison Plots
```{r echo=FALSE}
test %>%
  dplyr::filter(!duplicated(paste(QTL,algorithm))) %>%
  ggplot(., mapping = aes(x = detected, y = abs(Effect), fill = divergent)) +
  theme_minimal() +
  geom_violin(alpha = 0.8, draw_quantiles = seq(0,1,0.25)) + 
  facet_grid(algorithm ~ .) +
  labs(x = "Genome-Wide Association Status",
       y = "abs(QTL Effect)") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergent Region?") + 
  theme(legend.position = "top") + 
  ggtitle("How Impactful Are Divergent QTL?")
```

#### Manhattan Plots of False-Positives
```{r echo=FALSE}
# Intra-Chromosomal False-Positive
intrachrom.FPs <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>%
  dplyr::filter(as.numeric(dist.from.QTL) > 0)
intrachrom.FPs.gr <- GenomicRanges::GRanges(seqnames = intrachrom.FPs$CHROM, 
                                            ranges = IRanges(start = intrachrom.FPs$startPOS, 
                                                             end = intrachrom.FPs$endPOS),
                                            QTL = intrachrom.FPs$QTL)
divergent.FPs <- IRanges::findOverlapPairs(intrachrom.FPs.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL,first.X.seqnames, first.X.start, first.X.end, 
                second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","startPOS","endPOS","div.start","div.end"))


print("Intra-Chromosomal False-Positives")
intrachrom.FPs %>%
  dplyr::mutate(divergent = ifelse(test = QTL %in% divergent.FPs$QTL, 
                                   yes = "Divergent", 
                                   no = "Non-Divergent")) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = divergent)) +
  theme_minimal() +
  geom_point(alpha = 0.4, shape = 21) +
  facet_grid(algorithm~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergent Region?") + 
  theme(legend.position = "top") + 
  ggtitle("Intra-Chromosomal False-Positives")



# Extra-Chromosomal FPs
extrachrom.FPs <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive")
extrachrom.FPs.gr <- GenomicRanges::GRanges(seqnames = extrachrom.FPs$CHROM, 
                                            ranges = IRanges(start = extrachrom.FPs$startPOS, 
                                                             end = extrachrom.FPs$endPOS),
                                            QTL = extrachrom.FPs$QTL)
divergent.FPs <- IRanges::findOverlapPairs(extrachrom.FPs.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL,first.X.seqnames, first.X.start, first.X.end, 
                second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","startPOS","endPOS","div.start","div.end"))
extrachrom.FPs %>%
  dplyr::mutate(divergent = ifelse(test = QTL %in% divergent.FPs$QTL, 
                                   yes = "Divergent", 
                                   no = "Non-Divergent")) %>%
  ggplot(., mapping = aes(x = as.numeric(POS)/1000000, y = log10p, fill = divergent)) +
  theme_minimal() +
  geom_point(alpha = 0.4, shape = 21) +
  facet_grid(algorithm~CHROM) +
  labs(x = "Genomic position (Mb)",
       y = expression(-log[10](italic(p)))) +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergent Region?") + 
  theme(legend.position = "top") + 
  ggtitle("Extra-Chromosomal False-Positives")
```

```{r eval=FALSE, include=FALSE}
rep = as.character(sample(seq(1:50), size = 1))
rep = "1"
herit = "0.6"
algo = "LMM-EXACT-INBRED"
closest.FP.df %>%
  dplyr::filter(Rep == rep,
                h2 == herit,
                algorithm == algo) %>%
  dplyr::select(QTL, Rep, dist.from.QTL, Simulated, Detected, Frequency, CHROM, peakPOS)
```

