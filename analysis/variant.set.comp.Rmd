---
title: "Hard-Filtered v. Imputed Variants"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
editor_options:
  chunk_output_type: console
---

---
```{r setup, message=FALSE, warning=FALSE, include=FALSE}
require(tidyverse)
require(tidymodels)
require(nationalparkcolors)
require(RColorBrewer)
require(GenomicRanges)
```

Analysis date: `r format(Sys.time(), '%B %d, %Y')`

```{r message=FALSE, warning=FALSE, include=FALSE}
setwd("~/Documents/projects/NemaScan_Performance/")

# Load Hard-Filtered Simulations
load("data/NemaScan_Performance.Variant.Set.HF.chr125.20201112.RData")
hard.filtered <- simulation.metrics.df %>%
  tidyr::separate(col = sim,
                  into = c("nQTL","Rep","h2","MAF","effect_range","strain_set"), 
                  sep = "_", remove = F) %>%
  tidyr::separate(col = QTL,
                  into = c("CHROM","POS"), 
                  sep = ":", remove = F) %>%
  dplyr::mutate(h2 = as.factor(h2),
                POS = as.numeric(POS),
                startPOS = as.numeric(startPOS),
                peakPOS = as.numeric(peakPOS),
                endPOS = as.numeric(endPOS),
                var.exp  = as.numeric(var.exp),
                peak_id = as.numeric(peak_id),
                BETA = as.numeric(BETA),
                Effect = as.numeric(Effect),
                Frequency = as.numeric(Frequency),
                log10p = as.numeric(log10p),
                interval_size = as.numeric(interval_size),
                startPOS = if_else(condition = is.na(startPOS), # if simulated QTL wasn't detected, form an interval for overlap calcs
                                   true = POS, 
                                   false = startPOS),
                peakPOS = if_else(condition = is.na(peakPOS), 
                                   true = POS, 
                                   false = peakPOS),
                endPOS = if_else(condition = is.na(endPOS), 
                                   true = POS, 
                                   false = endPOS)) %>%
  dplyr::filter(algorithm %in% c("LMM-EXACT-INBRED","LMM-EXACT-LOCO")) %>%
  dplyr::mutate(variant.set = "hard-filtered")

# Load Imputed Simulations
# load("data/NemaScan_Performance.Variant.Set.Imputed.20201111.RData")
load("data/NemaScan_Performance.Variant.Set.Imputed.chr125.20201112.RData")
imputed <- simulation.metrics.df %>%
  tidyr::separate(col = sim,
                  into = c("nQTL","Rep","h2","MAF","effect_range","strain_set"), 
                  sep = "_", remove = F) %>%
  tidyr::separate(col = QTL,
                  into = c("CHROM","POS"), 
                  sep = ":", remove = F) %>%
  dplyr::mutate(h2 = as.factor(h2),
                POS = as.numeric(POS),
                startPOS = as.numeric(startPOS),
                peakPOS = as.numeric(peakPOS),
                endPOS = as.numeric(endPOS),
                var.exp  = as.numeric(var.exp),
                peak_id = as.numeric(peak_id),
                BETA = as.numeric(BETA),
                Effect = as.numeric(Effect),
                Frequency = as.numeric(Frequency),
                log10p = as.numeric(log10p),
                interval_size = as.numeric(interval_size),
                startPOS = if_else(condition = is.na(startPOS), # if simulated QTL wasn't detected, form an interval for overlap calcs
                                   true = POS, 
                                   false = startPOS),
                peakPOS = if_else(condition = is.na(peakPOS), 
                                   true = POS, 
                                   false = peakPOS),
                endPOS = if_else(condition = is.na(endPOS), 
                                   true = POS, 
                                   false = endPOS)) %>%
  dplyr::filter(algorithm %in% c("LMM-EXACT-INBRED","LMM-EXACT-LOCO")) %>%
  dplyr::mutate(variant.set = "imputed")



# Divergent Regions
common.divergent.regions <- data.table::fread("data/Common_divergent_regions_clustered.tsv") %>%
  dplyr::mutate(chr = as.factor(chr))
levels(common.divergent.regions$chr) <- c("1","2","3","4","5","6")
div.regions.gr <- GenomicRanges::GRanges(seqnames = common.divergent.regions$chr, 
                                         ranges = IRanges(start = common.divergent.regions$start, 
                                                          end = common.divergent.regions$stop))

# Finding Divergent QTLs: Hard-Filtered VCF Simulations
hf.pos.gr <- GenomicRanges::GRanges(seqnames = hard.filtered$CHROM, 
                                 ranges = IRanges(start = hard.filtered$POS, 
                                                  end = hard.filtered$POS),
                                 QTL = hard.filtered$QTL)

hf.interval.gr <- GenomicRanges::GRanges(seqnames = hard.filtered$CHROM, 
                                 ranges = IRanges(start = hard.filtered$startPOS, 
                                                  end = hard.filtered$endPOS),
                                 QTL = hard.filtered$QTL)

hf.divergent.markers <- IRanges::findOverlapPairs(hf.pos.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL, first.X.seqnames, first.X.start, second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","POS","div.start","div.end"))

hf.divergent.intervals <- IRanges::findOverlapPairs(hf.interval.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL, first.X.seqnames, first.X.start, first.X.end, second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","startPOS","endPOS","div.start","div.end"))


# Finding Divergent QTLs: Imputed VCF Simulations
imputed.pos.gr <- GenomicRanges::GRanges(seqnames = imputed$CHROM, 
                                 ranges = IRanges(start = imputed$POS, 
                                                  end = imputed$POS),
                                 QTL = imputed$QTL)

imputed.interval.gr <- GenomicRanges::GRanges(seqnames = imputed$CHROM, 
                                 ranges = IRanges(start = imputed$startPOS, 
                                                  end = imputed$endPOS),
                                 QTL = imputed$QTL)

imputed.divergent.markers <- IRanges::findOverlapPairs(imputed.pos.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL, first.X.seqnames, first.X.start, second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","POS","div.start","div.end"))

imputed.divergent.intervals <- IRanges::findOverlapPairs(imputed.interval.gr, div.regions.gr) %>%
  data.frame() %>%
  dplyr::select(first.QTL, first.X.seqnames, first.X.start, first.X.end, second.start, second.end) %>%
  `colnames<-`(c("QTL","CHROM","startPOS","endPOS","div.start","div.end"))


# Classifying
hard.filtered.div.df <- hard.filtered %>%
  dplyr::mutate(divergent.pos = ifelse(test = QTL %in% hf.divergent.markers$QTL, 
                                   yes = "Divergent Marker", 
                                   no = "Non-Divergent Marker"),
                divergent.interval = ifelse(test = QTL %in% hf.divergent.intervals$QTL, 
                                   yes = "Divergent Interval", 
                                   no = "Non-Divergent Interval"),
                detected = ifelse(test = Detected == TRUE, 
                                  yes = "Detected",
                                  no = "Not Detected"))

imputed.div.df <- imputed %>%
  dplyr::mutate(divergent.pos = ifelse(test = QTL %in% imputed.divergent.markers$QTL, 
                                   yes = "Divergent Marker", 
                                   no = "Non-Divergent Marker"),
                divergent.interval = ifelse(test = QTL %in% imputed.divergent.intervals$QTL, 
                                   yes = "Divergent Interval", 
                                   no = "Non-Divergent Interval"),
                detected = ifelse(test = Detected == TRUE, 
                                  yes = "Detected",
                                  no = "Not Detected"))

dat <- imputed.div.df %>%
  dplyr::full_join(hard.filtered.div.df)

poop<- dat %>%
  dplyr::group_by(h2, algorithm, variant.set, divergent.pos, Simulated, Detected) %>%
  dplyr::summarise(n())
```


## Simulation Parameters

NemaScan simulation performance was assessed with the following experimental parameters:

* ###### Number of Simulated QTL: ```r levels(as.factor(dat$nQTL))```
* ###### Sample Population(s): ```r levels(as.factor(dat$strain_set))```
* ###### Heritability(ies): ```r levels(as.factor(dat$h2))```
* ###### MAF(s): ```r levels(as.factor(dat$MAF))```
* ###### Number of Replicates per Regime: ```r max(as.numeric(dat$Rep))```
* ###### QTL Effect Range: ```r levels(as.factor(dat$effect_range))```
* ###### Algorithm: ```r levels(as.factor(dat$algorithm))```
* ###### Variant Set: ```r levels(as.factor(dat$variant.set))```

## Simulated QTL Locations
```{r simulated QTL locations, echo=FALSE}
dat %>%
  dplyr::filter(Simulated == TRUE,
                !duplicated(QTL)) %>%
  dplyr::filter(!is.na(CHROM)) %>%
  ggplot(mapping = aes(x = POS/1000000, y = Effect, fill = divergent.pos)) + 
  theme_bw() + 
  geom_point(shape = 21) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence") +
  facet_grid(variant.set~CHROM, drop = TRUE, scales = "free", space = "free") + 
  labs(x = "Genomic position (Mb)",
       y = "Causal QTL Effect",
       title = "Where were QTL simulated?")

dat %>%
  dplyr::filter(Simulated == TRUE) %>%
  dplyr::filter(!is.na(CHROM)) %>%
  ggplot(mapping = aes(x = Frequency, fill = variant.set)) +
  theme_bw() + 
  geom_density(alpha = 0.6) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[c(2,4)], name = "Variant Set") + 
  theme(legend.position = "top") + 
  xlim(c(0.05,0.5)) + 
  labs(x = "Minor Allele Frequency",
       y = "Frequency of Simulated QTL (Smoothed Density)")

dat %>%
  dplyr::filter(Simulated == TRUE) %>%
  dplyr::filter(!is.na(CHROM)) %>%
  ggplot(., mapping = aes(x = abs(Effect), fill = variant.set)) +
  theme_bw() + 
  geom_density(alpha = 0.6) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[c(2,4)], name = "Variant Set") + 
  theme(legend.position = "top") + 
  labs(x = "abs(QTL Effect)",
       y = "Frequency of Simulated QTL (Smoothed Density)")
```

## Performance Analysis

```{r power precision resolution, echo=FALSE}
power <- dat %>%
  dplyr::group_by(h2, variant.set, divergent.pos, algorithm) %>%
  yardstick::sens(truth = Simulated, estimate = Detected) %>%
  dplyr::mutate(.metric = "Power")

precision <- dat %>%
  dplyr::group_by(h2, variant.set, divergent.pos, algorithm) %>%
  yardstick::precision(truth = Simulated, estimate = Detected) %>%
  dplyr::mutate(.metric = "Precision")

resolution <- dat %>%
  dplyr::filter(Simulated == TRUE) %>%
  dplyr::filter(!is.na(var.exp)) %>%
  dplyr::select(CHROM, POS, Simulated, Frequency, interval_size, algorithm, h2, Simulated.QTL.VarExp, variant.set, divergent.pos) %>%
  dplyr::group_by(h2, variant.set, divergent.pos, algorithm) %>%
  dplyr::summarise(mean(interval_size), median(interval_size), sd(interval_size), 
                   mean(Simulated.QTL.VarExp), median(Simulated.QTL.VarExp), sd(Simulated.QTL.VarExp))

summarized <- power %>%
  dplyr::full_join(., precision) %>%
  tidyr::pivot_wider(names_from = .metric, values_from = .estimate) %>%
  dplyr::left_join(.,resolution) %>%
  dplyr::mutate(mean.interval.Mb = `mean(interval_size)`/1000000,
                median.interval.Mb = `median(interval_size)`/1000000,
                sd.interval.Mb = `sd(interval_size)`/1000000, 
                mean.PVE = `mean(Simulated.QTL.VarExp)`*100,
                median.PVE = `median(Simulated.QTL.VarExp)`*100,
                sd.PVE = `sd(Simulated.QTL.VarExp)`*100,
                FPR = 1- Precision)
```

```{r pr curve, echo=FALSE}
# CAVEAT: TNR = 0, CIs are relevant and we don't want to exclude tagged variants
dat %>%
  dplyr::group_by(h2, variant.set, divergent.pos, algorithm) %>%
  yardstick::pr_curve(Simulated, log10p) %>%
  ggplot(., mapping = aes(x = recall, y = precision, group = h2, colour = h2)) + 
  theme_bw() + 
  geom_path() +
  scale_colour_brewer(palette = "RdPu", name = "Trait Heritability") +
  facet_grid(variant.set~divergent.pos, scales = "free", space = "free") +
  ylim(c(0,1)) + 
  labs(x = "Recall", y = "Precision")
```

### Mapping Performance with Imputed Variants vs. Hard-Filtered Variants

```{r power precision plots, echo=FALSE}
summarized %>%
  ggplot(., mapping = aes(x = h2, y = Power, fill = variant.set)) +
  theme_bw() +
  geom_jitter(height = 0, width = 0.01, alpha = 0.8, shape =21, size = 4) +
  facet_grid(.~divergent.pos, scales = "free", space = "free") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[c(2,4)], name = "Variant Set") + 
  scale_shape_manual(values = c(21,22), name = "Algorithm") + 
  ylim(c(0,1)) + 
  labs(title = "Power v. Heritability",
       x = expression(italic(h^2)))

summarized %>%
  ggplot(., mapping = aes(x = h2, y = FPR, fill = variant.set)) +
  theme_bw() +
  geom_jitter(height = 0, width = 0.01, alpha = 0.8, shape =21,size = 4) +
  facet_grid(.~divergent.pos, scales = "free", space = "free") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$RockyMountains[c(2,4)], name = "Variant Set") + 
  scale_shape_manual(values = c(21,22), name = "Algorithm") + 
  ylim(c(0,1)) + 
  labs(title = "FPR v. Heritability",
       x = expression(italic(h^2)))

summarized %>%
  ggplot(., mapping = aes(x = h2, y = mean.interval.Mb, fill = divergent.pos)) +
  theme_bw() +
  geom_pointrange(aes(ymin = mean.interval.Mb-sd.interval.Mb,
                      ymax = mean.interval.Mb+sd.interval.Mb), alpha = 0.8, shape = 21) +
  facet_grid(~ variant.set + algorithm, scales = "free", space = "free") +
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence") +
  scale_shape_manual(values = c(21,22), name = "Algorithm") + 
  theme(legend.position = "top") + 
  labs(title = "Resolution v. Heritability",
       x = expression(italic(h^2)))
```


## Divergent Regions and False-Positives

```{r divergent region breakdown, echo=FALSE}
dat %>%
  dplyr::filter(Simulated == TRUE) %>% 
  dplyr::group_by(algorithm, variant.set, divergent.pos, Detected) %>%
  dplyr::summarise(n()) %>%
  tidyr::pivot_wider(values_from = `n()`, names_from = divergent.pos) %>%
  as.data.frame()

dat %>%
  dplyr::filter(Simulated == FALSE) %>% # should only be false positives
  dplyr::group_by(algorithm, variant.set, divergent.pos) %>%
  dplyr::summarise(n()) %>%
  tidyr::pivot_wider(values_from = `n()`, names_from = divergent.pos) %>%
  as.data.frame()

reps <- dat %>%
  dplyr::group_by(algorithm, h2, Rep, variant.set) %>%
  tidyr::nest()

# data = reps$data[[214]]
# rep = reps$Rep[[214]]
# h2 = reps$h2[[214]]
# variant.set = reps$variant.set[[214]]

closest.FP.calc <- function(data, rep, h2, variant.set, algorithm){
# ALL REPS SEPARATED:
  chrom.split <- data %>%
    dplyr::group_by(CHROM) %>%
    tidyr::nest()

# CHROMOSOME LOOP START
  closest.FP <- list()
  for(i in 1:length(chrom.split$data)){
  rep.CHROM <- chrom.split$data[[i]]
# SEARCH FOR CLOSEST SIMULATED QTL
# CALCULATE ABS(DISTANCE) FROM IT
  if(TRUE %in% rep.CHROM$Simulated){
    n.true.qtl <- length(rep.CHROM$Simulated[which(rep.CHROM$Simulated == TRUE)])
    # more than 1 simulated QTL on the chromosome
    if(n.true.qtl > 1){
      simulated.QTL.POS <- rep.CHROM %>%
      dplyr::filter(Simulated == TRUE) %>%
      dplyr::select(POS) %>%
      as.list()
    
      dist.from.QTL <- list()
      for(j in 1:nrow(rep.CHROM)){
        QTL.dists <- list()
        for(k in 1:length(simulated.QTL.POS[[1]])){
        QTL.dists[[k]] <- rep.CHROM[j,]$POS - simulated.QTL.POS[[1]][k]
      }
      dist.from.QTL[[j]] <- min(abs(unlist(QTL.dists)))
    }
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = unlist(dist.from.QTL))%>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])
    
  } else {
    # only 1 simulated QTL on the chromosome
    simulated.QTL.POS  <- rep.CHROM %>%
      dplyr::filter(Simulated == TRUE) %>% 
      dplyr::select(POS) %>%
      as.numeric()
    
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = abs(as.numeric(rep.CHROM$POS) - simulated.QTL.POS)) %>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])
  }
} else {
    closest.FP[[i]] <- rep.CHROM %>%
      dplyr::mutate(dist.from.QTL = "Extra-Chromosomal False-Positive")%>%
      dplyr::mutate(CHROM = chrom.split$CHROM[[i]])}
  }
  do.call(rbind, closest.FP) %>%
    as.data.frame() %>%
    dplyr::mutate(Rep = rep, 
                  h2 = h2,
                  variant.set = variant.set,
                  algorithm = algorithm)
}
closest.FP.nested <- purrr::pmap(.l = list(reps$data,
                                      reps$Rep,
                                      reps$h2,
                                      reps$variant.set,
                                      reps$algorithm), 
                                 .f = closest.FP.calc)
closest.FP.df <- do.call(rbind, closest.FP.nested)
```

### Intra-Chromosomal False-Positives
```{r echo=FALSE, fig.height=7, fig.width=5}
closest.intraFP.summary <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL != "Extra-Chromosomal False-Positive") %>% # only intra-chrom
  dplyr::filter(Detected == TRUE,
                Simulated == FALSE) %>% # only FPs
  dplyr::group_by(CHROM, h2, variant.set, divergent.pos, algorithm) %>%
  dplyr::summarise(mean(as.numeric(dist.from.QTL))/1000000,
                   sd(dist.from.QTL)/1000000,
                   n()) %>%
  `colnames<-`(c("CHROM","h2","variant.set","divergent.pos","algorithm","mean.QTL.dist","sd.QTL.dist","n"))

ggplot(closest.intraFP.summary, mapping = aes(x = variant.set, y = n, 
                                              fill = divergent.pos, alpha = h2)) + 
  theme_bw() + 
  geom_col(colour = "black") + 
  facet_grid(algorithm ~ CHROM) + 
  theme(legend.position = "right", 
        legend.direction = "vertical",
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence")+
  labs(x = "Chromosome",
       y = "Intra-Chromosomal False-Positives")


ggplot(closest.intraFP.summary, mapping = aes(x = variant.set, y = mean.QTL.dist, 
                                              fill = divergent.pos, colour = h2)) + 
  theme_bw() + 
  geom_pointrange(aes(ymin = mean.QTL.dist-sd.QTL.dist,
                      ymax = mean.QTL.dist+sd.QTL.dist), shape = 21, size = 1) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence") +
  scale_colour_brewer(palette = "Set1") + 
  facet_grid(algorithm ~ CHROM) + 
  theme(legend.position = "right", 
        legend.direction = "vertical",
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) + 
  labs(x = "Chromosome",
       y = "Distance from Nearest Simulatd QTL (Mb)")
```

### Extra-Chromosomal False-Positives
```{r echo=FALSE, fig.height=5, fig.width=8}
closest.extraFP.summary <- closest.FP.df %>%
  dplyr::filter(dist.from.QTL == "Extra-Chromosomal False-Positive") %>%
  dplyr::group_by(CHROM, algorithm, h2, variant.set, divergent.interval) %>%
  dplyr::summarise(n(), mean(interval_size/1000000), sd(interval_size/1000000))

ggplot(closest.extraFP.summary, mapping = aes(x = variant.set, y =`n()`, fill = divergent.interval, alpha = h2)) + 
  theme_bw() + 
  geom_col(position = "stack", colour = "black") + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence") +
  facet_grid(algorithm~CHROM) + 
    theme(legend.position = "top", 
        legend.direction = "horizontal",
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) + 
  labs(x = expression(italic(h^2)),
       y = "Extra-Chromosomal False-Positives")

ggplot(closest.extraFP.summary, mapping = aes(x = variant.set,
                                              y =`mean(interval_size/1000000)`, 
                                              fill = divergent.interval, colour = h2)) + 
  theme_bw() + 
  geom_jitter(shape = 21, width = 0.05, size = 2) + 
  scale_fill_manual(values = nationalparkcolors::park_palettes$Arches[c(3,1)], name = "Divergence") +
  facet_grid(algorithm~CHROM) + 
    theme(legend.position = "top", 
        legend.direction = "horizontal",
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) + 
  labs(x = "Variant Set",
       y = "False-Positive Interval Width (Mb)")
```


